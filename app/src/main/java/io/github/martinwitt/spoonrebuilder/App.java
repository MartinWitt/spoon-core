/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.github.martinwitt.spoonrebuilder;

import io.github.martinwitt.spoonrebuilder.fixes.CastSniperFixer;
import io.github.martinwitt.spoonrebuilder.fixes.GetActualClassProcessor;
import io.github.martinwitt.spoonrebuilder.fixes.NewInstanceProcessor;
import io.github.martinwitt.spoonrebuilder.fixes.TemplateParameterProcessor;
import io.github.martinwitt.spoonrebuilder.fixes.VarArgsFixer;
import org.apache.commons.lang3.tuple.Pair;
import spoon.Launcher;
import spoon.reflect.CtModel;
import spoon.reflect.cu.SourcePosition;
import spoon.reflect.declaration.CtAnnotation;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.sniper.SniperJavaPrettyPrinter;

import java.io.File;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.regex.Pattern;
import java.util.stream.Stream;

public class App {

    public static void main(String[] args) throws IOException {
        Launcher launcher = createLauncher();
        CtModel model = launcher.buildModel();
        GenericTypeRemover remover = new GenericTypeRemover();
        remover.setFactory(model.getRootPackage().getFactory());
        model.getAllTypes().forEach(remover::process);
        GenericVisitor visitor = new GenericVisitor();
        model.getAllTypes().forEach(v -> v.accept(visitor));
        GenericReferenceRemover genericReferenceRemover = new GenericReferenceRemover(remover);
        model.getElements(new TypeFilter<>(CtTypeReference.class))
                .forEach(genericReferenceRemover::process);
        List<CtMethod<?>> methods = model.getElements(new TypeFilter<>(CtMethod.class));
        NewInstanceProcessor newInstanceProcessor = new NewInstanceProcessor();
        methods.forEach(newInstanceProcessor::process);
        GetActualClassProcessor getActualClassProcessor = new GetActualClassProcessor();
        methods.forEach(getActualClassProcessor::process);
        TemplateParameterProcessor templateParameterProcessor = new TemplateParameterProcessor();
        methods.forEach(templateParameterProcessor::process);
        // Fixes:
                model.getElements(new TypeFilter<>(CtAnnotation.class)).stream()
                        .filter(v -> v.getName().equals("Experimental")).forEach(CtElement::delete);
        methods.stream().filter(v -> v.hasAnnotation(Override.class))
        .forEach(v -> v.replace(v.clone()));
        launcher.prettyprint();
        Path root = Path.of("spooned");
        try (Stream<Path> walk = Files.walk(Path.of("spoon"))) {
            walk.filter(v -> !v.toString().endsWith("java"))
            .filter(v -> !v.toString().contains(".git")).forEach(oldPath -> {
                try {
                    Path newLocation = root.resolve(oldPath);
                    if (Files.isDirectory(oldPath)) {
                        Files.createDirectories(newLocation);
                    } else {
                        Files.copy(oldPath, newLocation, StandardCopyOption.REPLACE_EXISTING);
                    }
                } catch (Exception e) {
                    System.out.println(oldPath.toString() + " can't be written to "
                            + Path.of("spooned", oldPath.toString()));
                }
            });
        }
        CastSniperFixer sniperFixer = new CastSniperFixer(model.getAllTypes());
        VarArgsFixer varArgsFixer = new VarArgsFixer();
        try (Stream<Path> walk = Files.walk(Path.of("spooned"))) {
            walk.forEach(sniperFixer::accept);
        }
        try (Stream<Path> walk = Files.walk(Path.of("spooned"))) {
            walk.forEach(varArgsFixer::accept);
        }
    }

    private static Launcher createLauncher() {
        Launcher launcher = new Launcher();
        launcher.addInputResource("spoon/src/main");
        launcher.getEnvironment().setEncoding(StandardCharsets.UTF_8);
        launcher.getEnvironment().setSourceOutputDirectory(new File("spooned/spoon/src/main/java"));
        launcher.getEnvironment().setAutoImports(true);
        launcher.getEnvironment().setPrettyPrinterCreator(
                () -> new SniperJavaPrettyPrinter(launcher.getEnvironment()));
        return launcher;
    }

    private static BracketFileFixer createBracketFileFixerAbstractTypingContext() {
        return new BracketFileFixer("AbstractTypingContext", List.of(
                Pair.of(Pattern.quote("((CtTypeParameterReference))"),
                        "(CtTypeParameterReference)"),
                Pair.of(Pattern.quote("((CtWildcardReference))"), "(CtWildcardReference)")));
    }
    
    private static BracketFileFixer createBracketFileFixerClassTypingContext() {
        return new BracketFileFixer("ClassTypingContext", List.of(
                Pair.of(Pattern.quote("((CtTypeParameterReference))"),
                        "(CtTypeParameterReference)"),
                Pair.of(Pattern.quote("((CtWildcardReference))"), "(CtWildcardReference)")));
    }
    
    /**
    * Modify an element such that the sniper printer detects it as modified, without changing its final content. This
    * forces it to be sniper-printed "as-is".
    */
    private static void markElementForSniperPrinting(CtElement element) {
        if (element == null) {
            return;
        }
        SourcePosition pos = element.getPosition();
        element.setPosition(SourcePosition.NOPOSITION);
        element.setPosition(pos);
    }
}
