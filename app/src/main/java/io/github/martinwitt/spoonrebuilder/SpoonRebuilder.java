/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package io.github.martinwitt.spoonrebuilder;

import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.stream.Stream;
import io.github.martinwitt.spoonrebuilder.fixes.CastSniperFixer;
import io.github.martinwitt.spoonrebuilder.fixes.FileFixer;
import io.github.martinwitt.spoonrebuilder.fixes.GenericTypeArgumentsFixer;
import io.github.martinwitt.spoonrebuilder.fixes.GetActualClassProcessor;
import io.github.martinwitt.spoonrebuilder.fixes.GetAnnotationFixer;
import io.github.martinwitt.spoonrebuilder.fixes.MetaModelFixer;
import io.github.martinwitt.spoonrebuilder.fixes.TemplateParameterProcessor;
import io.github.martinwitt.spoonrebuilder.fixes.VarArgsFixer;
import spoon.Launcher;
import spoon.reflect.CtModel;
import spoon.reflect.declaration.CtAnnotation;
import spoon.reflect.declaration.CtElement;
import spoon.reflect.declaration.CtMethod;
import spoon.reflect.reference.CtTypeReference;
import spoon.reflect.visitor.filter.TypeFilter;
import spoon.support.sniper.SniperJavaPrettyPrinter;

public class SpoonRebuilder {

    private Path spoonFolderPath;
    private Path outputPath;

    public SpoonRebuilder(Path spoonFolderPath, Path outputPath) {
        this.spoonFolderPath = spoonFolderPath;
        this.outputPath = outputPath;
    }

    public void rebuild() throws IOException {
        Launcher launcher = createLauncher();
        CtModel model = launcher.buildModel();
        GenericTypeRemover remover = new GenericTypeRemover();
        remover.setFactory(model.getRootPackage().getFactory());
        model.getAllTypes().forEach(remover::process);
        GenericVisitor visitor = new GenericVisitor();
        model.getAllTypes().forEach(v -> v.accept(visitor));
        // safety first KEKW
        model.getAllTypes().forEach(v -> v.accept(visitor));
        GenericReferenceRemover genericReferenceRemover = new GenericReferenceRemover(remover);
        model.getElements(new TypeFilter<>(CtTypeReference.class))
                .forEach(genericReferenceRemover::process);
        List<CtMethod<?>> methods = model.getElements(new TypeFilter<>(CtMethod.class));
        GetActualClassProcessor getActualClassProcessor = new GetActualClassProcessor();
        methods.forEach(getActualClassProcessor::process);
        TemplateParameterProcessor templateParameterProcessor = new TemplateParameterProcessor();
        methods.forEach(templateParameterProcessor::process);
        GetAnnotationFixer getAnnotationFixer = new GetAnnotationFixer();
        methods.forEach(getAnnotationFixer::process);
        MetaModelFixer metaModelFixer = new MetaModelFixer();
        model.getAllTypes().forEach(metaModelFixer::process);
        // Fixes:
        removeExperimentalAnnotation(model);
        resetOverridePositions(methods);
        launcher.prettyprint();
        Path root = outputPath;
        copyNonJavaFiles(root);
        FileFixer fileFixer = new FileFixer(
            new CastSniperFixer(model.getAllTypes())
                .andThen(new VarArgsFixer())
                .andThen(new GenericTypeArgumentsFixer())
        );
        try (Stream<Path> walk = Files.walk(outputPath)) {
            walk.forEach(fileFixer);
        }
        
    }

    private void copyNonJavaFiles(Path root) throws IOException {
        try (Stream<Path> walk = Files.walk(spoonFolderPath)) {
            walk.filter(v -> !v.toString().endsWith("java"))
            .filter(v -> !(v.toString().contains(".git") || v.toString().contains(".class"))).forEach(oldPath -> {
                try {
                    Path newLocation = root.resolve(oldPath);
                    if (Files.isDirectory(oldPath)) {
                        Files.createDirectories(newLocation);
                    } else {
                        Files.copy(oldPath, newLocation, StandardCopyOption.REPLACE_EXISTING);
                    }
                } catch (Exception e) {
                    System.out.println(oldPath.toString() + " can't be written to "
                            + Path.of("spooned", oldPath.toString()));
                }
            });
        }
    }

    private static void resetOverridePositions(List<CtMethod<?>> methods) {
        methods.stream().filter(v -> v.hasAnnotation(Override.class))
        .forEach(v -> v.replace(v.clone()));
    }

    private static void removeExperimentalAnnotation(CtModel model) {
        model.getElements(new TypeFilter<>(CtAnnotation.class)).stream()
                .filter(v -> v.getName().equals("Experimental")).forEach(CtElement::delete);
    }

    private Launcher createLauncher() {
        Launcher launcher = new Launcher();
        launcher.addInputResource(
                Path.of(spoonFolderPath.toString(), "src", "main", "java").toString());
        launcher.setSourceOutputDirectory(
                Path.of(outputPath.toString(), "spoon", "src", "main", "java").toString());
        launcher.getEnvironment().setEncoding(StandardCharsets.UTF_8);
        launcher.getEnvironment().setAutoImports(true);
        launcher.getEnvironment().setPrettyPrinterCreator(
                () -> new SniperJavaPrettyPrinter(launcher.getEnvironment()));
        return launcher;
    }
}
